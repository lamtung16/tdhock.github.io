---
layout: post
title: Generate publications page
description: Parsing bibtex and generating markdown
---

I have been updating my
[publications](https://tdhock.github.io/publications/) page by editing
markdown for several years. Today I updated my self-citation database,
[TDH-refs.bib](/assets/TDH-refs.bib), so that is is consistent with
that publications page. In this post we explore the extent to which it would be possible to generate the publications page, using the bib file as a source.

```{r Ropts, echo=FALSE}
repo.dir <- normalizePath("..")
post.id <- "2024-08-15-auto-pubs-page"
fig.path <- file.path(repo.dir, "assets", "img", post.id)
knitr::opts_chunk$set(
  dpi=100,
  fig.path=paste0(fig.path, "/"),
  fig.width=10,
  fig.process=function(path)sub(repo.dir, "", path, fixed=TRUE),
  fig.height=4)
options(width=120)
if(FALSE){
  knitr::knit(paste0(post.id, ".Rmd"))
}
```

## Parse bib into R

Parsing bibtex files is easy using regex. In fact, that is one of the
examples on `?nc::capture_all_str`:

```{r}
refs.bib <- "~/tdhock.github.io/assets/TDH-refs.bib"
refs.vec <- readLines(refs.bib)
at.lines <- grep("^@", refs.vec, value=TRUE)
str(at.lines)
```

The output above shows that there are currently 56 lines that start
with `@` in the bib file. Below we use a regex to convert each item
into one row of a data table:

```{r}
refs.dt <- nc::capture_all_str(
  refs.vec,
  "@",
  type="[^{]+", tolower,
  "[{]",
  ref="[^,]+",
  ",\n",
  fields="(?:.*\n)+?.*",
  "[}]\\s*(?:$|\n)")
str(refs.dt)
```

The output above shows that the bib file was converted to a table with 56 rows.

## Parsing fields 

First we look at the number of lines with an equals sign, each of which is probably a field.

```{r}
eq.lines <- grep("=", refs.vec, value=TRUE)
str(eq.lines)
```

Above we see 390 fields.

Below we parse the `fields` column:

```{r}
strip <- function(x)gsub("^\\s*|,\\s*$", "", gsub('[{}"]', "", x))
refs.fields <- refs.dt[, nc::capture_all_str(
  fields,
  "\\s*",
  variable="\\S+", tolower,
  "\\s*=",
  value=".*", strip),
  by=.(type, ref)]
refs.fields
```

Above we see 390 fields, consistent with the simpler `grep` parsing above.

## Verify clean

Normally there should not be any quotes or curly braces in fields:

```{r}
cat(grep('[{}"]', refs.fields$value, value=TRUE), sep="\n\n")
```

## Formatting the parsed data

The publications page is organized as follows

* chronologically, newest on top.
* heading `###` for in progress, and each year.
* bullet `-` for each publication.

Each publication has 

* Names like Last1 F1, Last2 F2.
* Title then period.
* Venue/publisher.
* then links.

The links at the end are not stored in the bib file, so that is not
possible to output. (exercise for reader!)

But we can get the other info.

## Venues

```{r}
library(data.table)
refs.wide <- dcast(refs.fields, type + ref ~ variable)
refs.wide[, .(
  type,
  year,
  journal=substr(journal,1,10),
  vol=volume, num=number,
  booktitle=substr(booktitle,1,10),
  note=substr(note,1,10),
  school=substr(school,1,10))]
```

As can be seen in the table above, we can use various fields to define the venue of publication:

* `article`: most journal articles have a `volume` and `number`. The only exception is a recently published article that has not yet been assigned a volume.
* `incollection` and `inproceedings`: can use `booktitle`.
* `unpublished`: can use `note`.
* `phdthesis`: can use `school`.

These rules are encoded below,

```{r}
refs.wide[, venue := fcase(
  type=="article", paste0(
    journal, ifelse(
      is.na(volume),
      paste0(", DOI: ", gsub("[.]", " . ", doi)),
      paste0(
        " ",
        volume,
        ifelse(is.na(number), "", sprintf("(%s)", number))
      )
    )
  ),
  grepl("^in", type), booktitle,
  type=="phdthesis", school,
  type=="unpublished", note
)][, .(type, year, venue=substr(venue, nchar(venue)-30,nchar(venue)))]
```

## Authors

Author names come in two forms:

* Family, Given1 Given2
* Given1 Given2 Family

```{r}
subject <- c("Toby Dylan Hocking", "Hocking, Toby Dylan")
alt.pattern <- nc::alternatives_with_shared_groups(
  family="[A-Z][^,]+",
  given="[^,]+",
  list("^", given, " ", family, "$"),
  list("^", family, ", ", given, "$"))
nc::capture_first_vec(subject, alt.pattern)
```

The pattern above matches either of the two forms.
Below we use it to match all of the data.

```{r}
(authors <- refs.wide[, {
  complete <- strsplit(author, split=" and ")[[1]]
  data.table(complete, nc::capture_first_vec(
    complete,
    alt.pattern,
    nomatch.error=FALSE))
}, by=ref
][
, abbrev := gsub("[a-z. ]", "", given)
][
, show := ifelse(is.na(family), complete, paste(family, abbrev))
][])
```

The table above shows all names standardized to a common format in the `show` column.
Below we verify that all names matched.

```{r}
authors[is.na(family)]
```

The table above shows that there are no entries that did not match the regex, which is OK.

```{r}
abbrev.dt <- authors[, .(
  authors_abbrev=paste(show, collapse=", ")
), by=ref]
abbrev.dt[, length(grep("Hocking",authors_abbrev))]
```

The output above shows that there are 57 items for which I am listed as an author.

```{r}
abbrev.dt[, .(ref, authors_abbrev=substr(authors_abbrev,1,30))]
```

The output above shows the abbreviated author list is reasonable.

## Output markdown

The code below joins the authors back to the original table, then outputs markdown.

```{r results='asis'}
abbrev.wide <- refs.wide[
  abbrev.dt, on="ref"
][, let(
  heading = ifelse(type=="unpublished", "In Progress", year),
  citation = sprintf("- %s (%s). %s. %s.", authors_abbrev, year, title, venue)
)][order(-heading, -year, authors_abbrev)]
abbrev.some <- abbrev.wide[unique(heading)[1:3], .SD[1:2], on="heading", by=heading]
abbrev.some[
, .(markdown=sprintf("### %s\n%s\n", heading, paste(citation, collapse="\n")))
, by=heading
][
, cat(paste(markdown, collapse="\n"))
]
```

## Another output

One advantage of this is that we can easily modify output formats.

```{r}
some.out <- abbrev.some[, .(
  figure=sprintf(
    '<img src="/assets/img/publications/%s.png" width="150" />',
    ref),
  published=heading, authors_abbrev, title, venue)]
knitr::kable(some.out)
```

## Make sure pdflatex likes it

```{r}
latex.dir <- tempfile()
dir.create(latex.dir)
file.copy(refs.bib, latex.dir)
article.tex <- file.path(latex.dir, "article.tex")
article.code <- sprintf(r"{\documentclass{article}
\usepackage{natbib}
\usepackage{fullpage}
\begin{document}
I have several scientific contributions \citep{%s}.
\bibliographystyle{abbrvnat}
\bibliography{%s}
\end{document}
}",
paste(refs.wide[order(year), ref], collapse=","),
sub(".bib$", "", basename(refs.bib)))
cat(article.code, file=article.tex)
system(paste("cd",latex.dir,"&& pdflatex article && bibtex article && pdflatex article && pdflatex article && evince article.pdf &"))
```
