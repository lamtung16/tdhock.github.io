---
layout: post
title: Indirect reverse dependencies
description: Computing the entire graph
---

```{r Ropts, echo=FALSE}
```{r Ropts, echo=FALSE}
repo.dir <- normalizePath("..")
post.id <- "2022-10-19-indirect-rev-deps/"
fig.path <- file.path(repo.dir, "assets", "img", post.id)
knitr::opts_chunk$set(
  dpi=100,
  fig.path=fig.path,
  fig.width=8,
  fig.process=function(path)sub(repo.dir, "", path, fixed=TRUE),
  fig.height=4)
if(FALSE){
  knitr::knit("2022-10-19-indirect-rev-deps.Rmd")
}
```

For a recent grant proposal submission to the National Science
Foundation POSE program, I wanted to make an argument that the
`data.table` R package is one of the most used, out of all R
packages.

I therefore wrote some code to compute the number of indirect reverse
dependencies for all R packages. First, download meta-data from the
current CRAN,

```{r}
library(data.table)
if(!file.exists("packages.rds")){
  u <- paste0(
    "https://cloud.r-project.org/web/packages/packages.rds")
  download.file(u, "packages.rds")
}
packages <- readRDS("packages.rds")
pkg.dt <- data.table(packages)[is.na(Path)]
nrow(pkg.dt)
names(pkg.dt)
```

Then, we can get direct reverse imports,

```{r}
imp.by <- pkg.dt[, .(
  imported.by=strsplit(`Reverse imports`, ", ")[[1]]
), by=.(Imports=Package)]
imp.by[!is.na(imported.by)]
imp.by[Imports=="data.table"]
```

Then, we can use a loop to recursively compute reverse imports,


```{r}
order.i <- 0
ord.dt.list <- list()
order.pkgs <- pkg.dt[, .(Package, Imports=Package)]
while(nrow(order.pkgs)){
  print(order.i <- order.i+1)
  order.deps <- imp.by[
    order.pkgs, 
    on="Imports", nomatch=0L, allow.cartesian=TRUE]
  if(nrow(order.deps)){
    ord.dt.list[[order.i]] <- data.table(order.i, order.deps)
  }
  order.pkgs <- unique(order.deps[, .(Package, Imports=imported.by)])
}
sapply(ord.dt.list, nrow)
(ord.dt <- do.call(rbind, ord.dt.list))
rbind(pkgs.in.ord=length(unique(ord.dt$Package)), pkgs=nrow(pkg.dt))
```

Which packages were funded by NSF?

```{r}
pkg.dt[, Desc.no.newlines := gsub("\n\\s+", " ", Description)]
(nsf.pkgs <- pkg.dt[
  grep("NSF|National Science Foundation", Desc.no.newlines), 
  Package])
```

Which of the reverse imports were funded by NSF?

```{r}
dt.pkgs <- ord.dt[Package=="data.table", imported.by]
(int.pkgs <- intersect(nsf.pkgs, dt.pkgs))
```

The output above shows that there are four reverse imports that were
also funded by NSF.

What is the path of packages from each reverse import in the
dependency graph?

```{r}
select.dt <- data.table(
  rev.dep=int.pkgs,
  imported.by=int.pkgs, 
  Package="data.table")
path.dt.list <- list()
iteration <- 0
while(nrow(select.dt)){
  print(iteration <- iteration+1)
  dep.dt <- ord.dt[select.dt, on=.(imported.by, Package)]
  path.dt.list[[iteration]] <- dep.dt
  select.dt <- dep.dt[
    Imports != Package, 
    .(rev.dep, imported.by=Imports, Package)]
}
(path.dt <- do.call(rbind, path.dt.list)[
  order(Package, rev.dep, -order.i),
  .(Package, rev.dep, order.i, imported.by, Imports)])
```

The table above shows that there are two direct reverse imports
(futureheatwaves, hurricaneexposure) for which the path length (max
`order.i`) is 1. The `fdapace` package imports `Hmisc` which imports
`data.table` (path length 2), whereas `bizicount` imports `DHARMa`
which imports `gap` which imports `plotly` which imports `data.table`
(path length 4).

The code below can be used to compute the direct and all reverse
dependencies,

```{r}
max.order.list <- list(
  all=Inf,
  direct=1)
dep.type.counts.list <- list()
for(dep.type in names(max.order.list)){
  max.order <- max.order.list[[dep.type]]
  dep.type.counts.list[[dep.type]] <- ord.dt[order.i <= max.order, .(
    `Dependency type`=dep.type,
    dependent.packages=length(unique(na.omit(imported.by)))
  ), by=Package
  ][, `:=`(
    rank=rank(-dependent.packages),
    prop.bigger=1-rank(dependent.packages)/.N
  )][order(rank)]
}
(dep.type.counts <- do.call(rbind, dep.type.counts.list))
```

The `data.table` package appears near the top in terms of number of
dependent packages,

```{r}
(dt.counts <- dep.type.counts[Package=="data.table"])
```

The table above shows that `data.table` has 

* 1326 direct reverse imports, which is rank 11 among CRAN packages
  (only 10 other packages, 0.05% of all CRAN packages, have a larger
  number of reverse imports).
* 2661 packages which import either directly or indirectly, which is
  rank 45 among CRAN packages (only 44 other packages, 0.2% of all
  CRAN packages, have a larger number).

```{r}
library(ggplot2)
bin.dt <- data.table(bin=c(0,10^seq(0, 4, l=20)))
bin.hist <- bin.dt[
  dep.type.counts, 
  .(bin=x.bin, `Dependency type`),
  roll="nearest", 
  on=.(bin=dependent.packages)
][,
  .(n.packages=.N),
  by=.(`Dependency type`, bin)]
ggplot()+
  theme_bw()+
  geom_line(aes(
    bin, n.packages),
    color="grey50",
    size=2,
    data=bin.hist)+
  geom_vline(aes(
    xintercept=dependent.packages),
    data=dt.counts)+
  geom_text(aes(
    dependent.packages*0.9, Inf, 
    label=sprintf(
      "data.table rev. imports=%d\nrank=%d/%d packages\n%.2f%% of packages have\nlarger rev. dep. count", 
      dependent.packages, 
      rank, nrow(pkg.dt), prop.bigger*100)),
    data=dt.counts,
    hjust=1, 
    vjust=1.1)+
  facet_grid(. ~ `Dependency type`, labeller=label_both)+
  scale_y_log10(
    "Number of packages with that\nreverse dependency count (log scale)")+
  scale_x_log10(
    "Reverse dependency count (number of other packages which import, log scale)")

```
