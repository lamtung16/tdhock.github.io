---
layout: post
title: AUC and AUM in torch
description: Demonstration of auto-grad
---

```{r Ropts, echo=FALSE}
repo.dir <- normalizePath("..")
post.id <- "2024-10-10-torch-roc-aum"
fig.path <- file.path(repo.dir, "assets", "img", post.id)
knitr::opts_chunk$set(
  dpi=100,
  fig.path=paste0(fig.path, "/"),
  fig.width=10,
  fig.process=function(path)sub(repo.dir, "", path, fixed=TRUE),
  fig.height=4)
conda.env <- "2023-08-deep-learning"
Sys.setenv(RETICULATE_PYTHON=sprintf(if(.Platform$OS.type=="unix")
  ##"/home/tdhock/.local/share/r-miniconda/envs/%s/bin/python"
  "/home/tdhock/miniconda3/envs/%s/bin/python"
  else "~/Miniconda3/envs/%s/python.exe", conda.env))
reticulate::use_condaenv(conda.env, required=TRUE)
in_render <- !is.null(knitr::opts_knit$get('rmarkdown.pandoc.to'))
in_knit <- isTRUE(getOption('knitr.in.progress'))
options(width=120)
if(FALSE){
  knitr::knit(paste0(post.id, ".Rmd"))
}
```

The goal of this post is to show how to use torch to compute ROC-AUC
(classic evaluation metric for binary classification) and AUM (Area
Under Min of False Positive and False Negative rates, our newly
proposed surrogate loss).

## Introduction

TODO

## Conclusions

TODO

## Session info

```{r}
sessionInfo()
```
